# Component

## 개념

- 기존의 웹 프레임워크는 MVC 방식으로 정보, 화면, 구동 코드를 분리하여 관리하였다.
  - 모델(Model) → 정보
  - 뷰(View) → 화면
  - 컨트롤러(Controller) → 구동
- 이 방식은 코드 관리를 효율적으로 할 수 있다는 장점이 있으나, MVC 각 요소의 의존성이 높아 재활용은 어려웠다.
- 하지만 웹 사이트의 화면은 각 요소가 비슷하고 반복적으로 사용한 경우가 많다.
- 이 점을 착안하여 컴포넌트가 등장하게 되었다.
- 컴포넌트는 MVC의 뷰를 독립적으로 구성하여 재사용도 할 수 있고, 컴포넌트를 통해 새로운 컴포넌트를 쉽게 만들 수도 있다.

> _TodaysPlan.jsx_

```jsx
import React from "react";

class TodaysPlan extends React.Component {
  render() {
    return <div className="message-container">놀러가자</div>;
  }
}

export default TodaysPlan;
```

> _App.js_

```jsx
import React from "react";
import TodaysPlan from "TodaysPlan"; // 파일 확장자 생략 가능

class App extends React.Component {
  render() {
    return (
      <div className="body">
        <TodaysPlan /> {/* 컴포넌트 추가 */}
      </div>
    );
  }
}

export default TodaysPlan;
```

### 웹팩 코드 검색 확장자(Webpack Module Resolution)

- **웹팩 코드 검색 확장자(Webpack Module Resolution)** 기능 때문에 파일의 확장자를 입력하지 않아도 자동으로 임포트할 수 있다.
- 웹팩은 임포트된 파일을 분석하여 하나의 자바스크립트 파일을 생성할 때 파일 위치를 검색한다.
- 이때 확장자 기능을 참조한다.
- `create-react-app`의 웹팩 코드 검색 확장자는 다음과 같은 순서로 파일을 검색한다.
  - (1) 확장자가 파일 이름에 있는 파일을 먼저 임포트한다.
  - (2) 확장자가 파일 이름에 없는 경우 웹팩 확장자 옵션(extentions)에 정의된 확장자 목록을 보고 해당 확장자 이름을 포함한 파일이 있는지 확인하여 임포트한다.
    - 예) `import 'MyFile'`의 경우, `MyFile.js` > `MyFile.jsx` 순서로 파일을 확인하여 임포트한다.
  - (3) 만약 지정 경로에 해당 파일이 없으면 같은 이름의 폴더는 없는지 검색한다.
    - 같은 이름의 폴더가 있다면 그 안에 있는 `index` 파일을 검색한다.
    - 예) `import 'MyComponent';`의 경우 `MyComponent.js` > `MyComponent.jsx` 순서로 확인한다.
    - 파일이 없으면 `MyComponent` 폴더를 검색하고 해당 폴더가 있는 경우 폴더 안에서 `index.js` > `index.jsx` 순서로 파일을 확인하여 임포트 한다.

## 컴포넌트 구성 요소

|    데이터 구성 요소    | 특징                                                            |
| :--------------------: | --------------------------------------------------------------- |
| **프로퍼티(Property)** | 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터     |
|        `state`         | 컴포넌트의 상태를 저장하고 변경할 수 있는 데이터                |
| **컨텍스트(Context)**  | 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터 |

## 프로퍼티(Property)

- 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용한다.
  - 이때 프로퍼티값은 수정할 수 <ins>없다.</ins>
- 다음과 같이 속성(Attribute) 형태로 전달되는 값을 프로퍼티(Property)라고 한다.

```js
class App extends React.component {
  render() {
    return {
      <div className="body">
        <MyComponent name="message" />   {/* name이라는 프로퍼티 전달 */}
      </div>
    }
  }
}

class MyComponent extends React.component {
  render() {
    const name = this.props.name;
    return <span>{name}</span>
  }
}
```

- 프로퍼티가 상위 컴포넌트(`App`)에서 하위 컴포넌트(`MyComponent`)로 전달된다.
  - '단방향으로 데이터가 흐른다'고 한다.

### 프로퍼티 사용법

- 프로퍼티의 자료형을 선언하는 방법은 리액트에서 제공하는 `prop-types`를 이용하면 된다.

> 문자열형 프로퍼티 사용하기

```js
// PropComponent.jsx
import React from "react";
import PropTypes from "prop-types";

class PropComponent extends React.Component {
  render() {
    return <div className="message-container">{this.props.name}</div>;
  }
}

// 자료형 선언 (문자열형)
PropComponent.propTypes = {
  name: PropTypes.string,
};

export default PropComponent;
```

```js
// App.js
import "./App.css";
import PropComponent from "./Components/PropComponent";

function App() {
  return <PropComponent name="안녕 리액트" />;
}

export default App;
```

> 다양한 프로퍼티 사용하기

```js
// ChildComponent.jsx
import React from "react";
import PropTypes from "prop-types";

class ChildComponent extends React.Component {
  render() {
    const { boolValue, numValue, arrayValue, objValue, nodeValue, funcValue } =
      this.props;

    return (
      <div>
        <span>불리언값: {boolValue}</span>
        <span>숫자값: {numValue}</span>
        <span>배열값: {arrayValue}</span>
        <span>객체값: {String(objValue)}</span>
        <span>노드값: {nodeValue}</span>
        <span>함수값: {String(funcValue)}</span>
      </div>
    );
  }
}

ChildComponent.propTypes = {
  boolValue: PropTypes.bool,
  numValue: PropTypes.number,
  arrayValue: PropTypes.arrayOf(PropTypes.number),
  objValue: PropTypes.object,
  nodeValue: PropTypes.node,
  funcValue: PropTypes.func,
};

export default ChildComponent;
```

```js
// App.js
import "./App.css";
import ChildComponent from "./Components/ChildComponent";

function App() extends React.Component {
  render() {
    const array = [1, 2, 3];
    const obj = { name: '제목', age: 30 }
    const node = <h1>노드</h1>
    const func = () => { console.log("메시지"); };
  }
  return (
    <ChildComponent
      boolValue={true}
      numValue={1}
      arrayValue={array}
      objValue={obj}
      nodeValue={node}
      funcValue={func}
    />
  );
}

export default App;
```

> 불리언 프로퍼티 사용하기

- 불리언은 `true` 또는 `false` 만 정의할 수 있는 특수한 자료형이다.
- `true`의 경우 프로퍼티의 이름만 선언해도 전달할 수 있다.

```js
<ChildComponent boolValue />
```

- `false`는 이름을 생략하면 된다.

```js
<ChildComponent />
```

```jsx
// BooleanComponent.jsx
import React from "react";
import PropTypes from "prop-types";

class BooleanComponent extends React.Component {
  render() {
    // 불리언 타입을 조건문에 적용한 예제
    const message = this.props.bored
      ? "놀러 가자"
      : "하던 일 열심히 마무리하기";
    return <div className="message-container">{message}</div>;
  }
}

// 자료형을 선언하는 예제
BooleanComponent.propTypes = {
  bored: PropTypes.bool,
};

export default BooleanComponent;
```

```js
// App.js
import "./App.css";
import ChildComponent from "./Components/ChildComponent";

function App() extends React.Component {
  render() {
    return (
      <div>
        <div><b>지루할 때:</b><BooleanComponent bored /></div>  {/* true */}
        <div><b>즐거울 때:</b><BooleanComponent /></div>   {/* false */}

      </div>
    )
  }
}

export default App;
```

> 필수 프로퍼티 사용하기

```js
import React from "react";
import PropTypes from "prop-types";

class ChildComponent2 extends React.Component {
  render() {
    const { objValue, requiredStringValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
        <div>필수값: {requiredStringValue}</div>
      </div>
    );
  }
}

ChildComponent2.propTypes = {
  // 객체형 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
  // 필수 프로퍼티
  requiredStringValue: PropTypes.string.isRequired,   {/* 필수 프로퍼티 */}
};

export default ChildComponent2;
```

> 프로퍼티에 기본값 지정하기

```jsx
import React from "react";
import PropTypes from "prop-types";

class DefaultPropsComponent extends React.Component {
  render() {
    let message1 = "";
    if (this.props.boolValue === false) {
      message1 = "boolValue 기본값이 false입니다";
    }
    let message2 = "";
    if (this.props.boolValueWithoutDefault === false) {
      message2 = "boolValueWithoutDefault 기본값이 false입니다";
    }
    return (
      <div className="message-container">
        {message1}
        {message2}
      </div>
    );
  }
}

DefaultPropsComponent.propTypes = {
  boolValue: PropTypes.bool,
  boolValueWithoutDefault: PropTypes.bool,
};

// 기본값 선언
DefaultPropsComponent.defaultProps = {
  boolValue: false,
};

export default DefaultPropsComponent;
```

> 자식 프로퍼티 사용하기

- JSX도 마크업 표현식을 사용할 수 있다.
- JSX에서는 컴포넌트 하위에 배치한 노드(또는 컴포넌트)를 하위 컴포넌트에서 프로퍼티로 접근할 수 있게 해준다.

```js
import "./App.css";
import ChildProperty from "./Components/ChildProperty";

function App() extends React.Component {
  render() {
    return (
      <div>
        <ChildProperty>
          <div><span>자식 노드</span></div>
        </ChildProperty>
      </div>
    );
  }
}

export default App;
```

- `ChildProperty` 컴포넌트에서는 `this.props.children`과 같은 방법으로 `<div><span>자식 노드</span></div>` 자식 노드를 쉽게 받을 수 있다.

```jsx
import React, { Component } from "react";
import PropTypes from "prop-types";

class ChildProperty extends Component {
  render() {
    return <div>{this.props.children}</div>;
  }
}
ChildProperty.propTypes = {
  children: PropTypes.node,
};
export default ChildProperty;
```

- 다음과 같이 별도의 프로퍼티를 통해 자식 노드를 전달해도 된다.

```js
import "./App.css";
import ChildProperty from "./Components/ChildProperty";

function App() extends React.Component {
  render() {
    return (
      <div>
        <ChildProperty children={<div><span>자식 노드</span></div>} />
      </div>
    );
  }
}

export default App;
```

## 컴포넌트 상태 관리

- 프로퍼티는 바꿀 수 없다는 특징이 있다.
- 프로퍼티를 바꾸려면 `state`를 사용하며, `state`를 사용하여 컴포넌트의 상태를 관리할 수 있다.

```jsx
// StateExample.jsx
import React from "react";

class StateExample extends React.Component {
  constructor(props) {
    super(props);

    // 상태 정의
    this.state = {
      loading: true,
      formData: "no data",
    };
    // 이후 콜백 함수를 다룰때 bind를 선언하는 부분에 대해 다룹니다
    this.handleData = this.handleData.bind(this);
    // 생성 후 4초 후에 handleData를 호출합니다.
    setTimeout(this.handleData, 4000);
  }
  handleData() {
    const data = "new data";
    const { formData } = this.state;
    // 상태 변경
    this.setState({
      loading: false,
      formData: data + formData,
    });
    // this.state.loading 은 현재 true 입니다.
    // 이후 호출될 출력함수에서의 this.state.loading은 false입니다.
  }
  // 다음과 같이 setState함수를 사용할 수 있습니다.
  // handleData(data) {
  //   this.setState(function(prevState) {
  //     const newState = {
  //       loading : false,
  //       formData: data + prevState.formData,
  //     };
  //     return newState;
  //   });
  // }
  render() {
    return (
      <div>
        {/* 상태 데이터는 this.state로 접근 가능합니다. */}
        <span>로딩중: {String(this.state.loading)}</span>
        <span>결과: {this.state.formData}</span>
      </div>
    );
  }
}

export default StateExample;
```

```js
// App.js
import "./App.css";
import StateExample from "./Components/StateExample";

function App() extends React.Component {
  render() {
    return (
      <div>
        <StateExample />
      </div>
    );
  }
}

export default App;
```

### `state`를 사용할 때 주의할 점

- 생성자(Constructor)에서 <ins>반드시</ins> 초기화 해야 한다.
  - 그렇지 않으면 외부 함수에서 `state` 값에 접근할 수 없다.
- `state` 값을 변경할 때는 `setState()` 함수(상태 관리 함수)를 반드시 사용해야 한다.
  - `render()` 함수로 화면을 그려주는 시점은 리액트 엔진이 정하기 때문이다.
    - `state`를 변경하더라도, `render()` 함수는 새로 호출되지 않ㄴ는다.
  - `setState()` 함수를 호출하여 `state` 값을 변경하면 리액트 엔진이 자동으로 `render()` 함수를 호출하므로 화면에 변경된 `state` 값을 새롭게 출력할 수 있다.
- `setState()` 함수는 비동기로 처리되며, `setState()` 코드 이후로 연결된 함수들의 실행이 완료된 시점에 화면 동기화 과정을 거친다.

```js
// 일반 함수를 사용한 예
handleData(data) {
  this.setState(function(prevState) {
    const newState = {
      loading: false,
      formData: data + prevState.fromData,
    };

    return newState;
  });
}

// 화살표 함수를 사용한 예
handleData(data) {
  this.setState(prevState => ({
    loading: false,
    formData: data + prevState.fromData
  });
}
```

### 클래스 인스턴스 변수와 `forceUpdate()` 함수로 `state`` 관리하기

- 꼭 `setState()` 함수로 `state`를 관리할 필요는 없다.
- 만약 출력 검증 작업 없이 함수가 호출될 때마다 새롭게 화면을 출력하고 싶다면 클래스 인스턴스 변수와 화면을 강제로 출력해주는 `forceUpdate()` 함수를 사용하면 된다.
- 이 방법은 리액트 성능에 제약이 있으므로 매번 새롭게 화면을 출력해야 하는 경우가 아니라면 가급적 사용하지 않는 것이 좋다.

```jsx
import React from "react";

class ForceUpdateExample extends React.Component {
  constructor(props) {
    super(props);
    // 상태 정의
    this.loading = true;
    this.formData = "no data";

    this.handleData = this.handleData.bind(this);

    // 생성 후 4초 후 handleData 호출
    setTimeout(this.handleData, 4000);
  }
  handleData() {
    const data = "new data";

    // 상태 변경
    this.loading = false;
    this.formData = data + this.formData;

    // 강제로 업데이트
    this.forceUpdate();
  }
  render() {
    return (
      <div>
        {/* 상태 데이터는 this.state로 접근 가능 */}
        <span>로딩중: {String(this.loading)}</span>
        <span>결과: {this.formData}</span>
      </div>
    );
  }
}

export default ForceUpdateExample;
```

## 컴포넌트 생명 주기

- 생명 주기 함수는 총 8종이 있으며, 리액트 엔진에서 자동으로 호출한다.
  - 개발자가 마음대로 호출할 수 없다.

### 생성 과정

- `constructor()`
- `getDerivedStateFromProp()`
- `render()`
- `componentDidMount()`

### 갱신 과정

- `getDerivedStateFromProp()`
- `shouldComponentUpdate()`
  - 반환값이 `true` 인 경우 이후 과정 진행
  - 반환값이 `false`인 경우 이후 과정이 모두 생략
- `render()`
- `getSnapshotBeforeUpdate()`
- `componentDidUpdate()`

### 소멸 과정

- `componentWillUnmount()`

```jsx
import React from "react";

class LifeCycle extends React.Component {
  static getDerivedStateFromProps() {
    console.log("getDerivedStateFromProps 호출");
    return {};
  }

  constructor(props) {
    super(props);

    // getDerivedStateFromProps() 함수를 사용하므로
    // 경고 메시지를 건너 뛰기 위해 state 초기값을 설정한다.
    this.state = {};
    console.log("constructor 호출");
  }

  componentDidMount() {
    console.log("componentDidMount 호출");
    // this.setState({ updated: true });
    this.forceUpdate();
  }

  componentDidUpdate() {
    console.log("componentDidUpdate 호출");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount 호출");
  }

  getSnapshotBeforeUpdate() {
    console.log("getSnapshotBeforeUpdate 호출");
    return {};
  }

  shouldComponentUpdate() {
    console.log("shouldComponentUpdate 호출");
    return true;
  }

  render() {
    console.log("render 호출");
    return null;
  }
}

export default LifeCycle;
```

## 클래스형 컴포넌트

- 클래스형 컴포넌트는 리액트 **생명 주기 함수**와 **컴포넌트 구성 요소**를 모두 포함하고 있다.
- 클래스형 컴포넌트는 2종류의 클래스를 사용한다.
  - `Component` 클래스
  - `PureComponent` 클래스

### `Component` 클래스

- `Component` 클래스는 **프로퍼티, `state` 와 생명 주기 함수가 들어있는 구조의 컴포넌트**를 만들 때 사용한다.

```jsx
import React from "react";

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log("생성 함수");
  }

  componentDidMount() {
    /* 상속 받은 생명 주기 함수 */
  }
  myMethod() {
    /* 추가 확장 함수 */
  }
  render() {
    /* 상속 받은 화면 출력 함수 */
  }
}

export default MyComponent;
```

### `PureComponent` 클래스

- `Component` 클래스를 상속 받은 클래스
- `shouldComponentUpdate()` 함수를 ‘얕은 비교’ 하도록 재정의 하였다.
- 즉, `PureComponent` 클래스로 만들어진 컴포넌트는 ‘얕은 비교를 통해 데이터가 변경된 경우’에만 `render()` 함수를 호출한다.
- 반면, `Component` 클래스로 만들어진 컴포넌트는 항상 `render()` 함수를 호출한다.

```jsx
import React from 'react';
import shallowEqual from 'shallow-equal';   // 얕은 비교를 위해 사용

export default PureComponent extends React.Component {
	shouldComponentUpdate(nextProps, nextState) {
		// 얕은 비교 진행
		return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState)
	}
}
```

#### 검증 비교를 위한 얕은 비교 알아보기

- `==` , `===` , `shallowEqual()` 함수를 이용하여 얕은 비교와 그렇지 않은 비교의 차이점을 알아보자.
- `shallow-equal` 라이브러리를 설치하려면 `npm install shallow-equal` 또는 `yarn add shallow-equal` 명령을 터미널에서 실행한다.

```jsx
import shallowEqual from "shallow-equal";

const obj = { name: "park" };
const myList = [1, 2, 3, obj];
const list1 = [1, 2, 3, obj];
const list2 = [1, 2, 3, { name: "park" }];

// 깊은 비교 (===)
myList == list1; // false (같은 요소를 가지고 있지만, 각각 새롭게 정의된 배열 이므로)

// 얕은 비교
shallowEqual(myList, list1); // true (배열 요소 하나하나 비교)
shallowEqual(list1, list2); // false (list2의 마지막 요소는 ojb와 같은 내용이지만, 새 객체이기 때문)
```
