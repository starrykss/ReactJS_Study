# JavaScript ES6 Preview

## 들어가며

- JavaScript ES6(ECMAScript2015)에 추가된 문법들을 빠르게 알아보자.

## 1️⃣ 템플릿 문자열(Template String)

- 기존의 **병합 연산자(`+`)** 를 사용하지 않고, **백팃(`｀`)** 으로 문자열을 표현할 수 있게 되었다.

```js
const word1 = "Hello, ";
const word2 = "World!";

// ES6 이전
const connectedString = word1 + word2;

// ES6 이후
const connectedString = `${word1} ${word2}`;
```

## 2️⃣ 전개 연산자(Spread Operator)

- 나열형 자료를 추출하거나 연결할 때 사용한다.
- 배열이나 객체, 변수명 앞에 마침표 3개(`...`)를 입력한다.
- 다만, 배열, 객체, 함수 인자 표현식(`[]`, `{}`, `()`) 안에서만 사용해야 한다.

```js
var ary1 = ["one", "two"];
var ary2 = ["three", "four"];

var objectOne = { one: 1, two: 2, other: 0 };
var objectTwo = { three: 3, four: 4, other: -1 };

// ES6 이전
var combined = [ary1[0], ary1[1], ary2[0], ary2[1]]; // 방법 1
var combined = ary1.concat(ary2); // 방법 2
var combined = [].concat(ary1, ary2); // 방법 3

var first = ary1[0];
var second = ary1[1];
var third = ary1[2] || "empty"; // || 연산자와 조합하면 추출할 배열 요소가 없을 때 기본값 지정 가능

function func() {
  var args = Array.prototype.slice.call(this, arguments);
  var first = args[0];
  var others = args.slice(1, args.length); // 인덱스 1(두번째 항목)부터 마지막 항목까지 추출
}

var combined = {
    one: objectOne.one,
    two: objectOne.two,
    three: objectTwo.three,
    four: objectTwo.four,
}
var combined = Object.assign({}, objectOne, objectTwo);
var combined = Object.assign({}, objectTwo, objectOne);
var others = Object.assign({}, combined);
delete others.other;

// ES6 이후
const combined = [...ary1, ...ary2];
const [first, second, three, 'empty', ...others] = ary1;
func(...args) { var [first, ...others] = args; }

var combined = {
    ...objectOne,   // 객체 전개 연산자
    ...objectTwo,
}
var { other, ...others } = combined;
```

## 3️⃣ 가변 변수와 불변 변수

- 기존 자바스크립트 문법은 변수 선언에 `var` 키워드를 사용하였지만, ES6에서는 값을 수정할 수 있는 가변 변수를 위한 `let` 키워드와 값을 수정할 수 없는 불변 변수를 위한 `const` 키워드를 사용한다.
  - `var` : 함수 범위
  - `let`, `const` : 블록 범위

```js
// ES6 가변 변수
let num = 1;
num = num * 3;
let str = "문자";
str = "다른 문자";
let arr = [];
arr = [1, 2, 3];
let obj = {};
obj = { name: "새 객체" };

// ES6 불변 변수
const num = 1;
num = 3; // 오류
const str = "문자";
str = "다른 문자"; // 오류
const arr = [];
arr = [1, 2, 3]; // 오류
const obj = {};
obj = { name: "내 이름" }; // 오류
```

- 다음과 같이 JavaScript 내장 함수를 사용하면 객체를 불변 변수로 수정하더라도 수정할 수 있다.

```js
const arr2 = [];
arr2.push(1);
arr2.splice(0, 0, 0);
arr2.pop();

const obj2 = {};
obj2["name"] = "내 이름";
Object.assign(obj2, { name: "새 이름" });
delete obj2.name;
```

- 하지만 위의 방식은 '무결성 제약 조건'에 위배'된 것이다.
- 무결성을 유지하면서 불변 변수의 값을 수정하려면 수정할 불변 변수를 새로 만들어 새값을 할당하는 방법으로 수정해야 한다. (새로 정의해야 한다는 개념에 가깝다.)

```js
const num1 = 1;
const num2 = num1 * 3;

const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4];
```

### 가변 내장 함수와 무결성 내장 함수

- **무결성 함수** : 객체나 배열을 직접 수정하는 것이 아니라 새 결과를 반환하는(무결성 제약 조건을 지키는) 함수
- **불변 변수** 를 사용하면 무결성 제약 규칙에 의해 변수가 변하는 시점을 쉽게 파악할 수 있고, 수정 전과 수정 후의 변수값을 비교할 수 있어 가변 변수보다 더 유용하다.
- 실제로 실무에서도 **가변 변수** 보다 **불변 변수** 를 더 많이 사용한다.

| 가변 내장 함수           | 무결성 내장 함수                                    |
| ------------------------ | --------------------------------------------------- |
| `push(...items)`         | `concat(...items)`                                  |
| `splice(s, c, ...items)` | `slice(0, s)` <br/> `.concat(...items, slice(s+c))` |
| `pop()`                  | `slice(0, len - 1)`                                 |
| `shift()`                | `slice(1)`                                          |
